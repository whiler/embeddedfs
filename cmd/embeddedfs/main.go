package main

import (
	"bytes"
	"flag"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"text/template"
	"time"
)

const TPL = `// Code generated by embeddedfs, DO NOT EDIT.
package {{ .Package }}

import (
	{{ range .Imports }}
	"{{ . }}"
	{{ end }}
)

var (
	{{ .VarName }} embeddedfs.FileSystem
)

func init() {
	{{ .VarName}} = embeddedfs.EmbeddedFileSystem(map[string]*embeddedfs.EmbeddedFile{ {{ range .Files }}
		"{{ .Path }}": &embeddedfs.EmbeddedFile{
			Info: &embeddedfs.FileInfo{
				RawName: {{ quote .Info.Name }},
				RawSize: {{ .Info.Size }},
				RawMode: {{ .Info.Mode }},
				RawModTime: time.Unix({{ unix .Info.Time }}, 0),
			},
			Content: []byte{ {{ range .Content }}{{.}},{{ end }} },
			Children: []*embeddedfs.FileInfo{ {{ range .Children }}
				&embeddedfs.FileInfo{
					RawName: {{ quote .Name }},
					RawSize: {{ .Size }},
					RawMode: {{ .Mode }},
					RawModTime: time.Unix({{ unix .Time }}, 0),
				},
			{{ end }} },
		},
	{{ end }}})
}`

var (
	generateTemplate = template.Must(template.New("").Funcs(template.FuncMap{
		"quote": strconv.Quote,
		"unix":  func(t time.Time) int64 { return t.Unix() },
	}).Parse(TPL))
	root    string
	out     string
	pkg     string
	name    string
	imports = []string{"time", "github.com/whiler/embeddedfs"}
)

type Info struct {
	Name string
	Size int64
	Mode uint32
	Time time.Time
}

type File struct {
	Path     string
	Info     *Info
	Content  []byte
	Children []*Info
}

type renderContext struct {
	Package string
	Imports []string
	VarName string
	Files   []*File
}

func init() {
	flag.StringVar(&root, "root", "", "path/to/embed/root")
	flag.StringVar(&name, "name", "", "EmbeddedFileSystem var name")
	flag.StringVar(&pkg, "package", "", "package name. if out is stdout, package is required, or use the dirname of out as default package")
	flag.StringVar(&out, "out", "", "path/to/output/file. default stdout")
}

func walk(absRoot string) (files []*File, err error) {
	offset := len(absRoot)
	err = filepath.Walk(absRoot, func(path string, info os.FileInfo, err error) error {
		relative := path[offset:]
		name := info.Name()
		children := make([]*Info, 0)
		bytes, _ := ioutil.ReadFile(path)
		if absRoot == path {
			relative = "/"
			name = ""
		}
		if fis, e := ioutil.ReadDir(path); e == nil {
			for _, fi := range fis {
				children = append(children, &Info{
					Name: fi.Name(),
					Size: fi.Size(),
					Mode: uint32(fi.Mode()),
					Time: fi.ModTime(),
				})
			}
		}
		files = append(files, &File{
			Path: relative,
			Info: &Info{
				Name: name,
				Size: info.Size(),
				Mode: uint32(info.Mode()),
				Time: info.ModTime(),
			},
			Content:  bytes,
			Children: children,
		})
		return err
	})
	return
}

func main() {
	var (
		err       error
		absRoot   string
		files     []*File
		buf       bytes.Buffer
		formatted []byte
		writer    = os.Stdout
	)

	flag.Parse()

	if "" == root {
		panic("root is required")
	}
	if "" == name {
		panic("name is required")
	}

	if "" == out {
		if "" == pkg {
			panic("package is required")
		}
	} else {
		absRoot, err = filepath.Abs(out)
		if err != nil {
			panic(err)
		}
		if "" == pkg {
			pkg = filepath.Base(filepath.Dir(absRoot))
		}
		writer, err = os.Create(out)
		if err != nil {
			panic(err)
		}
		defer writer.Close()
	}

	absRoot, err = filepath.Abs(root)
	if err != nil {
		panic(err)
	}

	files, err = walk(absRoot)
	if err != nil {
		panic(err)
	}

	err = generateTemplate.Execute(&buf, renderContext{
		Package: pkg,
		Imports: imports,
		VarName: name,
		Files:   files,
	})
	if err != nil {
		panic(err)
	}

	formatted, err = format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	_, err = writer.Write(formatted)
	if err != nil {
		panic(err)
	}
}
